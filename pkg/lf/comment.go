/*
 * LF: Global Fully Replicated Key/Value Store
 * Copyright (C) 2018-2019  ZeroTier, Inc.  https://www.zerotier.com/
 *
 * Licensed under the terms of the MIT license (see LICENSE.txt).
 */

package lf

import (
	"encoding/binary"
	"fmt"
)

const (
	commentAssertionNil                         byte = 0
	commentAssertionRecordCollidesWithClaimedID byte = 1

	commentReasonNone                 byte = 0 // No reason given
	commentReasonAutomaticallyFlagged byte = 1 // Issue detected automatically
	commentReasonManuallyFlagged      byte = 2 // A meat sack said so
)

// comment describes a record datum in a commentary record generated by a node.
type comment struct {
	subject   []byte // subject/target of comment
	assertion byte
	reason    byte
}

func (c *comment) string() string {
	var reason string
	switch c.reason {
	case commentReasonNone:
		reason = "no reason given"
	case commentReasonAutomaticallyFlagged:
		reason = "automatically flagged"
	case commentReasonManuallyFlagged:
		reason = "manually flagged"
	default:
		reason = fmt.Sprintf("unknown reason %.2x", c.reason)
	}

	switch c.assertion {
	case commentAssertionNil:
		return "nil"
	case commentAssertionRecordCollidesWithClaimedID:
		return fmt.Sprintf("record %x collides with an already-claimed ID (%s)", c.subject, reason)
	}

	return fmt.Sprintf("unknown assertion %.2x subject %x reason %.2x", c.assertion, c.subject, c.reason)
}

func (c *comment) appendTo(b []byte) []byte {
	var tmp [10]byte
	b = append(b, c.assertion, c.reason)
	b = append(b, tmp[0:binary.PutUvarint(tmp[:], uint64(len(c.subject)))]...)
	b = append(b, c.subject...)
	return b
}

func (c *comment) readFrom(b []byte) ([]byte, error) {
	if len(b) < 4 {
		return nil, ErrInvalidObject
	}

	c.assertion = b[0]
	c.reason = b[1]

	subLen, bytesRead := binary.Uvarint(b[2:])
	if bytesRead <= 0 {
		return nil, ErrInvalidObject
	}
	b = b[2+bytesRead:]
	if int(subLen) > len(b) { // >= since at least one byte of objLen will follow subject
		return nil, ErrInvalidObject
	}
	if subLen > 0 {
		c.subject = make([]byte, uint(subLen))
		copy(c.subject, b[0:len(c.subject)])
		b = b[len(c.subject):]
	} else {
		c.subject = nil
	}

	return b, nil
}
